# Internationalization Guide

This project uses [i18next](https://www.i18next.com/) with `react-i18next`, `i18next-browser-languagedetector`, and the ICU message format to provide runtime translations for the UI.

## File structure

```
src/
  i18n/
    config.ts            # Supported languages and defaults
    index.ts             # i18next initialization
    locales/
      en/common.json     # English translations (fallback)
      fi/common.json     # Finnish translations
      sv/common.json     # Swedish translations
    useLocale.ts         # Helper hook for t, setLang, number/date formatting
```

## Adding or editing translation keys

1. **Add the key to English first.** Use descriptive keys such as `hud.temperature` or `tasks.daily.ready`. Place new keys in `src/i18n/locales/en/common.json`.
2. Copy the key (with identical name) into the Finnish and Swedish files. All three files must contain the same set of keys â€“ CI will fail if they drift.
3. Prefer ICU message syntax for plurals and conditionals. Examples:
   * `"tasks.daily.ready": "{count, plural, one {# task ready to claim} other {# tasks ready to claim}}"`
   * `"prestige.level": "{hasName, select, true {Sauna tier {level} ({name})} other {Sauna tier {level}}}"`
4. Whenever possible, interpolate dynamic values instead of concatenating strings. Use named parameters (`{value}`, `{name}`, etc.) and pass data from the component via the `t` call.
5. Use the `useLocale` hook to access `t`, `setLang`, `formatNumber`, and `formatDate` in React components.

## Adding a new language

1. Add the language code to `SUPPORTED_LANGS` in `src/i18n/config.ts` and update `DEFAULT_LANG` if needed.
2. Create a new `common.json` file under `src/i18n/locales/<code>/` with the same keys as English.
3. Supply translations for every key. Tools such as [i18next-parser](https://github.com/i18next/i18next-parser) can help audit coverage, but the included `npm run check:i18n` script (see below) will already compare keys across locales.
4. Update documentation, QA checklists, and any locale-specific assets as necessary.

## Persisted language and routing

* Language detection looks at `?lng=<code>` query parameters, `localStorage`, and the browser locale (in that order). Supported languages are `fi`, `en`, and `sv`.
* When the user selects a language via the switcher, the preference is stored in `localStorage` and the `<html lang>` attribute is updated.

## Formatting helpers

The `useLocale` hook exposes `formatNumber` and `formatDate`, which wrap `Intl.NumberFormat` and `Intl.DateTimeFormat` using the active i18next language. Prefer these helpers over manual formatting to respect locale-specific conventions.

## Testing and CI

* Unit tests should render components with the `renderWithI18n` helper from `src/tests/testUtils.tsx`, ensuring consistent language selection.
* Run `npm test` to execute the Vitest suite.
* Run `npm run check:i18n` (added in `package.json`) to verify that all locale files contain the same keys. The script prints any differences and exits with a non-zero status if mismatches are found.

Keeping locale files synchronized and using ICU-friendly keys will ensure smooth future translations and easier maintenance.
